<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Backup Operators Schedule</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
/* === LOGO STYLES === */
.logo-container {
    text-align: center; /* Center the image */
    margin-bottom: 10px;
}
.logo-container img {
    max-width: 150px; /* Adjust the size of the logo */
    height: auto;
    border-radius: 5px;
}
/* === End Logo Styles === */

/* === NEXT SHIFTS SLIDER STYLES (DIMLIGHTED) === */
#nextShiftsWrapper {
    margin: 0 auto 20px auto;
    max-width: 1000px;
}
#nextShiftsContainer {
    display: flex;
    overflow-x: auto; /* Enables horizontal sliding/scrolling */
    gap: 10px;
    padding: 10px 0;
    white-space: nowrap; /* Prevents wrapping */
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch; /* Improves mobile scrolling */
    border: 1px solid #c9c9c9;
    border-radius: 6px;
    background-color: #f0f0f0; /* Soft, subtle background color */
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); /* Subtle inner shadow for depth */
}
.shift-card {
    flex: 0 0 200px; /* Card size: fixed width, no growing/shrinkinng */
    padding: 10px 15px;
    background-color: #E7E8EA; /* Dimmer card background */
    border-radius: 4px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.05); /* Soft, dim shadow */
    border-left: 5px solid #00A8E8; /* Blue accent remains */
    transition: transform 0.2s;
}
.shift-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.1); /* Slightly brighter on hover */
}
.shift-card-header {
    font-weight: bold;
    font-size: 1.1em;
    color: #444; /* Soft dark text */
    margin-bottom: 5px;
    overflow: hidden;
    text-overflow: ellipsis;
}
.shift-card p {
    margin: 2px 0;
    font-size: 0.9em;
    color: #555; /* Slightly muted date text */
}
.shift-card .date-range {
    font-weight: bold;
    color: #4D8BCA;
}
/* === End Next Shifts Slider Styles === */


/* === Color Palette === */
body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background-color: #ABB8C3;
}
h2 {
    text-align: center;
    color: #333;
    margin-bottom: 20px;
}

/* Top Section */
.top-section {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 15px;
    margin-bottom: 20px;
}
.top-section label {
    font-weight: bold;
}
.top-section input[type="date"], .top-section select {
    padding: 6px 10px;
    font-size: 14px;
    border: 1px solid #999;
    border-radius: 4px;
}
.top-section button {
    padding: 8px 14px;
    font-size: 14px;
    background-color: #94C83D;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
}
.top-section button:hover {
    background-color: #7DAE2F;
}

/* Authentication */
#authSection {
    text-align: center;
    margin-bottom: 20px;
}
#authSection input, #authSection button {
    padding: 6px 10px;
    font-size: 14px;
    margin: 5px;
    border-radius: 4px;
    border: none;
}
#authSection button {
    background-color: #4D8BCA; /* Blue for Login */
    color: white;
    cursor: pointer;
}
#authSection button:hover {
    background-color: #386B99;
}

/* Controls */
.controls {
    text-align: center;
    margin-bottom: 20px;
}
.controls h3 {
    margin-top: 15px;
    margin-bottom: 10px;
}
.controls input, .controls button {
    padding: 6px 10px;
    font-size: 15px;
    margin-right: 10px;
    border-radius: 4px;
    border: none;
}
.controls button {
    background-color: #94C83D;
    color: white;
    cursor: pointer;
}
.controls button:hover {
    background-color: #7DAE2F;
}
#logoutBtn {
    background-color: #cc0000;
}
#logoutBtn:hover {
    background-color: #a30000;
}

/* Shift Calculator */
#shiftCalculator {
    margin: 20px auto;
    padding: 15px;
    background-color: #e6f3ff;
    border: 1px solid #a8d5ff;
    border-radius: 5px;
    max-width: 500px;
    text-align: left;
}
#shiftCalculator label {
    font-weight: bold;
    display: block;
    margin-top: 10px;
}
#shiftCalculator input[type="date"] {
    width: 100%;
    box-sizing: border-box;
    margin-bottom: 10px;
}
#shiftCalculator .result {
    margin-top: 10px;
    font-size: 1.1em;
    font-weight: bold;
    color: #007bff;
}

/* Table */
.table-container {
    width: 100%;
    overflow-x: auto;
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}
table {
    width: 100%;
    border-collapse: collapse;
    min-width: 800px;
}
th, td {
    border: 1px solid #999;
    padding: 10px;
    text-align: left;
    font-size: 14px;
    white-space: nowrap;
}
th {
    background-color: #94C83D;
    color: white;
    text-align: center;
}
/* Ensure highlights override zebra striping */
tr:not(.highlight-today):not(.highlight-next):nth-child(even) { background-color: #F0F0F0; }
tr:not(.highlight-today):not(.highlight-next):nth-child(odd) { background-color: #E7E8EA; }
tbody tr {
    cursor: pointer; /* Indicate rows are clickable */
}

/* === Highlighting Styles === */
.highlight-today {
    background-color: #FFEA00 !important; /* Yellow */
    font-weight: bold;
}
.highlight-next {
    background-color: #C8FFC8 !important; /* Light Green */
}


/* Footer */
.note {
    text-align: center;
    background-color: #94C83D;
    color: white;
    font-weight: bold;
    padding: 12px;
    font-size: 16px;
    border-radius: 5px;
    margin-top: 15px;
}
.footer {
    text-align: center;
    font-size: 13px;
    color: #FFFFFF; /* Text color set to White for contrast */
    background-color: #00A8E8; /* FOOTER BACKGROUND COLOR (Cyan Blue) */
    font-style: italic;
    margin-top: 20px;
    padding: 10px 0;
    border-radius: 5px;
}

/* Action Buttons (Visible only to Full Admin) */
.rename-btn, .reset-btn, .delete-btn {
    padding: 4px 8px;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    margin: 2px;
    font-size: 13px;
}
.rename-btn { background-color: #888A8C; color: #fff; }
.rename-btn:hover { background-color: #6E7072; }
.reset-btn { background-color: #17a2b8; color: #fff; }
.reset-btn:hover { background-color: #117a8b; }
.delete-btn { background-color: #cc0000; color: #fff; }
.delete-btn:hover { background-color: #ff4444; }

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 10;
    left: 0; top: 0;
    width: 100%; height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.5);
}
.modal-content {
    background-color: #fefefe;
    margin: 10% auto;
    padding: 25px;
    border: 1px solid #888;
    width: 80%;
    max-width: 450px;
    border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}
.close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
}
.close:hover, .close:focus {
    color: #000;
    cursor: pointer;
}
.modal-content label {
    display: block;
    margin-top: 10px;
    font-weight: bold;
}
.modal-content input {
    width: 95%;
    padding: 8px;
    margin: 5px 0 15px 0;
    border: 1px solid #ccc;
    border-radius: 4px;
}
.modal-content button {
    padding: 8px 15px;
    margin-right: 10px;
}

/* Responsive */
@media(max-width:600px){
    th, td { font-size: 13px; padding: 8px; }
    .top-section { flex-direction: column; align-items: stretch; }
    .controls, #authSection {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    .controls input, .controls button, #authSection input, #authSection button {
        width: 100%;
        max-width: 300px;
        margin: 0 auto;
    }
    .modal-content {
        margin: 5% auto;
        width: 90%;
    }
    .shift-card {
        flex: 0 0 160px; /* Smaller cards for mobile */
        padding: 8px 12px;
    }
}
</style>
</head>
<body>

<div class="logo-container">
    <img src="oromia bank.png" alt="Oromia Bank"> 
</div>

<h2>Backup Operators Schedule</h2>

<div id="nextShiftsWrapper">
    <div id="nextShiftsContainer">
        </div>
</div>
<div class="top-section">
    <label for="startDate">Schedule Start Date (Shift starts next day):</label>
    <input type="date" id="startDate" onchange="generateScheduleByDate(this.value)">
    <button onclick="downloadPDF()">Download PDF</button>

    <label for="operatorFilter" id="filterLabel" style="display:none;">View Schedule:</label>
    <select id="operatorFilter" onchange="renderTable()" style="display:none;">
        <option value="">-- All Operators --</option>
    </select>
    
    <button onclick="openChangePasswordModal()" id="changePwdBtn" style="display:none;">Change Password</button>

    <button onclick="logout()" id="logoutBtn" style="display:none;">Logout</button>
    <button onclick="scrollToAdd()" id="adminActionsBtn">Admin Actions</button>
</div>

<div id="authSection">
    <input type="text" id="loginUsername" placeholder="Enter username (e.g., admin, view, or Your Name)">
    <input type="password" id="adminPassword" placeholder="Enter password">
    <button onclick="authenticate()">Login</button>
</div>

<div class="controls" id="adminControls" style="display:none;">
    <h3>Full Admin Controls (Add/Reset/Generate)</h3>
    <input type="text" id="operatorName" placeholder="Operator Name">
    <input type="text" id="mobileNumber" placeholder="Mobile Number">
    <button onclick="addOperator()">Add Operator</button>
    <button onclick="generateScheduleButton()">Generate Full Schedule</button>
    <button onclick="resetAll()">Clear ALL Data</button>

    <div id="shiftCalculator">
        <h3>Shift Range Calculator (10 Working Days, No Sundays)</h3>
        <label for="calcStartDate">Enter Shift Start Date:</label>
        <input type="date" id="calcStartDate" onchange="calculateShiftRange()">
        <div class="result">Shift End Date: <span id="calcEndDate">--</span></div>
        <div class="result">Total Working Days: <span id="calcWorkingDays">--</span></div>
    </div>
</div>

<div class="table-container">
    <table id="scheduleTable">
        <thead>
            <tr>
                <th>S/N</th>
                <th>Taken by</th>
                <th>Checked by</th>
                <th>Mobile number</th>
                <th>Date Range</th>
                <th id="actionsHeader">Actions</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
</div>

<div class="note">BACKUP OPERATORS SCHEDULE</div>

<div class="footer">© 2025 Backup Operators Schedule | All rights reserved | Developed by HAMBISA ADAMU.</div>

<div id="renameModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeRenameModal()">&times;</span>
        <h3>Rename Operator</h3>
        <label for="newName">New Name:</label>
        <input type="text" id="newName">
        <button onclick="confirmRename()">Rename</button>
        <button onclick="closeRenameModal()">Cancel</button>
    </div>
</div>

<div id="detailModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeDetailModal()">&times;</span>
        <h3>Schedule Details</h3>
        <p><strong>Operator:</strong> <span id="detailOperatorName"></span></p>
        <p><strong>Mobile:</strong> <span id="detailMobile"></span></p>
        <p><strong>Shift Start:</strong> <span id="detailStart"></span></p>
        <p><strong>Shift End:</strong> <span id="detailEnd"></span></p>
        <p><strong>Working Days:</strong> <span id="detailWorkingDays"></span></p>
    </div>
</div>

<div id="changePasswordModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeChangePasswordModal()">&times;</span>
        <h3>Change Password</h3>
        <label for="newOpPassword">New Password:</label>
        <input type="password" id="newOpPassword" placeholder="Enter new password">
        <label for="confirmOpPassword">Confirm Password:</label>
        <input type="password" id="confirmOpPassword" placeholder="Confirm new password">
        <button onclick="confirmPasswordChange()">Change Password</button>
    </div>
</div>

<script src="jspdf.umd.min.js"></script>
<script src="jspdf.plugin.autotable.min.js"></script>

<script>
// --- HARDCODED OPERATOR LIST ---
const INITIAL_OPERATORS_DATA = [
    { name: "ABRAHAM CHALA", mobile: "0913564114" },
    { name: "BERISO SHIBIRU", mobile: "0902911411" },
    { name: "HAMBISA ADAMU", mobile: "0913456466" } ,
    { name: "DAME TERFASSA", mobile: "0911117524" },
    { name: "TSION GIRMA", mobile: "0946700418" }
];
// -----------------------------------------------------

let operators = JSON.parse(localStorage.getItem('operators') || '[]');
let operatorPasswords = JSON.parse(localStorage.getItem('operatorPasswords') || '{}');

// Check if local storage is empty or operators are missing. If so, initialize with hardcoded data.
if (operators.length === 0 || !operators.some(op => INITIAL_OPERATORS_DATA.some(initOp => initOp.name === op.name))) {
    // Initialize passwords for all new operators
    INITIAL_OPERATORS_DATA.forEach(op => {
        if (!operatorPasswords[op.name]) {
            operatorPasswords[op.name] = 'op123'; // Default operator password
        }
    });
    localStorage.setItem('operatorPasswords', JSON.stringify(operatorPasswords));
    // The 'operators' array will be populated by init() calling generateFullSchedule()
}


let isAdmin = false; 
let isRestrictedAdmin = false;
let isOperator = false;
let loggedInUser = null; 
let renameIndex = null;

// Helper to get a clean date for comparison (00:00:00)
function getCleanDate(dateInput) {
    const d = new Date(dateInput);
    // Handle invalid dates early
    if (isNaN(d.getTime())) return new Date(NaN); 
    d.setHours(0, 0, 0, 0);
    return d;
}

// Today's date is set to October 8, 2025 (for demonstration/testing consistency)
const today = getCleanDate(new Date('2025-10-08T00:00:00')); 
// To use the ACTUAL current date and time, use this instead:
// const today = getCleanDate(new Date()); 

// --- Usernames and Passwords ---
const FULL_ADMIN_USER = 'admin';
const FULL_ADMIN_PWD = 'Admin@1234!@#$';

const RESTRICTED_ADMIN_PWD = 'view123'; 
const RESTRICTED_ADMIN_USER = 'view'; 

const SHIFT_LENGTH = 10; // 10 working days


/* Helper: Format date with month name */
function formatDate(date) {
    const options = { day: '2-digit', month: 'short', year: 'numeric' };
    const d = new Date(date);
    return isNaN(d) ? 'Invalid Date' : d.toLocaleDateString('en-US', options);
}

/**
 * Helper: Calculate the end date by counting exactly 10 working days (excluding Sundays).
 */
function calculateEndDate(startDate) {
    let workingDays = 0;
    let current = getCleanDate(startDate);
    
    // Start counting from the input date itself.
    while (workingDays < SHIFT_LENGTH) {
        if (current.getDay() !== 0) { // 0 = Sunday
            workingDays++; // Only count if it's NOT Sunday
        }
        
        // If we've reached the SHIFT_LENGTH (10 working days), 
        // the current date is the end date. Stop advancing.
        if (workingDays < SHIFT_LENGTH) { 
            current.setDate(current.getDate() + 1);
        }
    }
    
    // The current date is the 10th working day (Shift End).
    return current;
}

/* Helper: Count working days in a date range (excluding Sundays) */
function countWorkingDays(startDate, endDate) {
    let count = 0;
    let current = getCleanDate(startDate);
    const end = getCleanDate(endDate);
    
    // Iterate through each day from start to end (inclusive)
    while (current.getTime() <= end.getTime()) {
        if (current.getDay() !== 0) { // 0 = Sunday
            count++;
        }
        current.setDate(current.getDate() + 1);
    }
    return count;
}


/* --- Manual Shift Calculator (For checking one shift range) --- */
function calculateShiftRange() {
    const startDateInput = document.getElementById('calcStartDate').value;
    const endDateSpan = document.getElementById('calcEndDate');
    const workingDaysSpan = document.getElementById('calcWorkingDays');

    endDateSpan.textContent = '--';
    workingDaysSpan.textContent = '--';

    if (!startDateInput) return;

    const startDate = getCleanDate(startDateInput);
    if (isNaN(startDate.getTime())) return;

    const endDate = calculateEndDate(startDate);
    const workingDays = countWorkingDays(startDate, endDate);

    endDateSpan.textContent = formatDate(endDate);
    workingDaysSpan.textContent = `${workingDays} working days (Should be ${SHIFT_LENGTH})`;
}
/* ------------------------------------------- */


/**
 * Core function to generate the schedule based on a specific start date.
 */
function generateFullSchedule(officialStartDate) {
    // Only proceed if there are operators to schedule
    if (INITIAL_OPERATORS_DATA.length === 0) {
         operators = [];
         localStorage.setItem('operators', JSON.stringify(operators));
         return;
    }

    // Use the input date as the starting point for the schedule
    let startFromDate = getCleanDate(officialStartDate || today);

    // 1. Identify unique operator details (names, mobiles) from the INITIAL_OPERATORS_DATA
    const uniqueOperators = INITIAL_OPERATORS_DATA.map(op => ({ 
        name: op.name, 
        mobile: op.mobile 
    }));

    // 2. Define the target end date (one year from the chosen start date)
    const targetEnd = getCleanDate(startFromDate);
    targetEnd.setFullYear(targetEnd.getFullYear() + 1);
    targetEnd.setDate(targetEnd.getDate() - 1); // Makes it exactly 1 year span

    // 3. Clear existing schedule and rebuild from the ground up 
    operators = [];
    
    let opIndex = 0;
    let nextShiftStart = new Date(startFromDate);
    nextShiftStart.setHours(0, 0, 0, 0);
    
    // --- MODIFICATION: Shift Start = Schedule Start Date + 1 Day ---
    nextShiftStart.setDate(nextShiftStart.getDate() + 1);
    // ----------------------------------------------------------------
    

    // 4. Generate shifts until the target end date (1 year)
    while (nextShiftStart.getTime() <= targetEnd.getTime() && operators.length < 500) { // Safety break at 500 shifts
        const opDetails = uniqueOperators[opIndex];
        
        const shiftStart = new Date(nextShiftStart);
        const shiftEnd = calculateEndDate(shiftStart);
        shiftEnd.setHours(0, 0, 0, 0); // Ensure end date is clean
        
        // Only include the shift if its start is within the year range
        if (shiftStart.getTime() <= targetEnd.getTime()) {
             const newShift = {
                 name: opDetails.name,
                 checkedBy: opDetails.name, // "Checked by" is the same as "Taken by"
                 mobile: opDetails.mobile,
                 start: shiftStart.toISOString().split('T')[0],
                 end: shiftEnd.toISOString().split('T')[0]
             };
             operators.push(newShift);
        } else {
            break; // Stop if the next shift starts outside the target range
        }


        // Prepare for the next shift: Start the day after the current shift ends.
        nextShiftStart = new Date(shiftEnd);
        nextShiftStart.setDate(nextShiftStart.getDate() + 1);
        nextShiftStart.setHours(0, 0, 0, 0);
        
        opIndex = (opIndex + 1) % uniqueOperators.length;
    }
    
    localStorage.setItem('operators', JSON.stringify(operators));
}

/**
 * Triggered by the main date picker change.
 */
function generateScheduleByDate(dateString) {
    if (!dateString) return;
    
    const inputDate = getCleanDate(dateString);
    
    // Calculate the expected shift start from the input date (+1 day)
    const expectedShiftStart = new Date(inputDate);
    expectedShiftStart.setDate(expectedShiftStart.getDate() + 1);
    expectedShiftStart.setHours(0,0,0,0);

    const currentScheduleShiftStart = operators.length > 0 ? getCleanDate(operators[0].start) : null;
    
    // Only re-generate the schedule if the date input causes a change to the expected starting shift date
    if (!currentScheduleShiftStart || currentScheduleShiftStart.getTime() !== expectedShiftStart.getTime()) {
         generateFullSchedule(dateString);
    }
    
    renderTable();
    renderNextShifts(); // Update the sliding bar
}


function generateScheduleButton() {
    if (!isAdmin) return alert('Full Admin privileges required to generate the schedule.');
    const startDate = document.getElementById('startDate').value;
    if (!startDate) return alert('Please set the Schedule Start Date at the top.');
    
    generateFullSchedule(startDate);
    renderTable();
    renderNextShifts(); // Update the sliding bar
    alert("One-year schedule successfully generated!");
}

/* Populate Filter Dropdown */
function populateFilter() {
    const filter = document.getElementById('operatorFilter');
    // Use the INITIAL_OPERATORS_DATA for a reliable list of current operators
    const uniqueNames = [...new Set(INITIAL_OPERATORS_DATA.map(op => op.name).filter(n => n))]; 
    const currentSelection = filter.value;
    filter.innerHTML = '<option value="">-- All Operators --</option>';

    uniqueNames.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        if (name === currentSelection) {
            option.selected = true;
        }
        filter.appendChild(option);
    });
}

/* Render Table */
function renderTable() {
    const tbody = document.querySelector('#scheduleTable tbody');
    tbody.innerHTML = '';
    
    // Get the date from the input field for comparison
    const scheduleStartDateString = document.getElementById('startDate').value || today.toISOString().split('T')[0];
    const inputDate = getCleanDate(scheduleStartDateString);

    // Calculate the expected shift start from the input date (+1 day)
    const expectedShiftStart = new Date(inputDate);
    expectedShiftStart.setDate(expectedShiftStart.getDate() + 1);
    expectedShiftStart.setHours(0,0,0,0);

    const currentScheduleShiftStart = operators.length > 0 ? getCleanDate(operators[0].start) : null;
    
    // 1. Ensure the schedule is generated (starting from the input date + 1 day)
    if (!currentScheduleShiftStart || currentScheduleShiftStart.getTime() !== expectedShiftStart.getTime()) {
        generateFullSchedule(scheduleStartDateString);
    }
    
    // Handle case where no operators are configured
    if (operators.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="text-align:center;">No schedule data available. Add operators or generate a schedule.</td></tr>';
        return;
    }

    // 2. Determine base list (Full schedule, Operator's shifts, or Filtered operator's shifts)
    let baseOperators = operators;
    const selectedOperator = document.getElementById('operatorFilter').value;
    const isInputDateToday = inputDate.getTime() === today.getTime();

    if (isOperator) {
        baseOperators = operators.filter(op => op.name === loggedInUser);
    } else if (selectedOperator) {
        baseOperators = operators.filter(op => op.name === selectedOperator);  
    }
    
    // 3. Apply view filtering based on input date (if input date is today)
    let filteredOperators = baseOperators;
    let activeShiftIndexInFilteredList = -1;
    let nextShiftIndexInFilteredList = -1;
    
    if (isInputDateToday && !isOperator && !selectedOperator) {  
        // Find the currently active shift (today) in the FULL list
        const activeShiftGlobalIndex = operators.findIndex(op => {
            const opStart = getCleanDate(op.start);
            const opEnd = getCleanDate(op.end);
            return (today.getTime() >= opStart.getTime() && today.getTime() <= opEnd.getTime());
        });
        
        // If an active shift is found, slice the next 6 shifts (current + 5 next)
        if (activeShiftGlobalIndex !== -1) {
            filteredOperators = operators.slice(activeShiftGlobalIndex, activeShiftGlobalIndex + 6);
            activeShiftIndexInFilteredList = 0; // The active shift is now the first one in this small list
            nextShiftIndexInFilteredList = 1;
        } else {
            // If no active shift, find the nearest upcoming one and show 6 from there
            const upcomingShiftGlobalIndex = operators.findIndex(op => getCleanDate(op.start).getTime() > today.getTime());
            if (upcomingShiftGlobalIndex !== -1) {
                filteredOperators = operators.slice(upcomingShiftGlobalIndex, upcomingShiftGlobalIndex + 6);
                nextShiftIndexInFilteredList = 0; // The upcoming shift is now the first one in this small list
            }
        }
        
    } else {
        // If input date is NOT today, or if a user/operator filter is active, show the full list or filtered list
        filteredOperators = baseOperators;
        
        // Calculate the active shift and next shift in the *filtered* view for highlighting
        activeShiftIndexInFilteredList = filteredOperators.findIndex(op => {
            const opStart = getCleanDate(op.start);
            const opEnd = getCleanDate(op.end);
            return (today.getTime() >= opStart.getTime() && today.getTime() <= opEnd.getTime());
        });
        
        if (activeShiftIndexInFilteredList !== -1) {
              nextShiftIndexInFilteredList = activeShiftIndexInFilteredList + 1;
              if (nextShiftIndexInFilteredList >= filteredOperators.length) nextShiftIndexInFilteredList = -1;
        } else {
              nextShiftIndexInFilteredList = filteredOperators.findIndex(op => getCleanDate(op.start).getTime() > today.getTime());
        }
    }
    
    // Control visibility of the Actions column header
    const actionsHeader = document.getElementById('actionsHeader');
    actionsHeader.style.display = isAdmin ? 'table-cell' : 'none';

    // Calculate the number of unique operators for S/N resetting
    const uniqueOperatorCount = INITIAL_OPERATORS_DATA.length;

    // 4. Render the table with highlights
    filteredOperators.forEach((op, index) => {
        const tr = document.createElement('tr');
        tr.onclick = () => showDetailModal(op);

        let highlightClass = '';
        
        if (index === activeShiftIndexInFilteredList) {
            highlightClass = 'highlight-today';
        } else if (index === nextShiftIndexInFilteredList) {
            highlightClass = 'highlight-next';
        }

        tr.className = highlightClass;
        
        // --- START: S/N Reset Logic ---
        let serialNumber;
        if (uniqueOperatorCount > 0) {
            // Find the index of the operator name in the INITIAL_OPERATORS_DATA list
            const initialOperatorIndex = INITIAL_OPERATORS_DATA.findIndex(initialOp => initialOp.name === op.name);
            
            // This is the S/N within the current cycle (1, 2, 3, 4, 5, 1, 2, ...)
            serialNumber = initialOperatorIndex !== -1 ? initialOperatorIndex + 1 : '-'; 
            
            // If a filter is applied (operator view or Today's view), S/N should be sequential
            if (isOperator || selectedOperator || isInputDateToday) {
                serialNumber = index + 1;
            }
        } else {
            serialNumber = index + 1;
        }
        // --- END: S/N Reset Logic ---
        
        // Find the index in the FULL list for actions
        const globalIndex = operators.findIndex(o => o.start === op.start && o.name === op.name); 
        const actionsCell = isAdmin ? 
            `<td>
                <button class="rename-btn" onclick="event.stopPropagation(); openRenameModal(${globalIndex})">Rename</button>
                <button class="reset-btn" onclick="event.stopPropagation(); resetOperator(${globalIndex})">Reset</button>
                <button class="delete-btn" onclick="event.stopPropagation(); deleteOperator(${globalIndex})">Delete</button>
            </td>` : 
            `<td style="display:none;">—</td>`;
            
        tr.innerHTML = `
            <td>${serialNumber}</td>
            <td>${op.name}</td>
            <td>${op.checkedBy}</td>
            <td>${op.mobile}</td>
            <td>${formatDate(op.start)} - ${formatDate(op.end)}</td>
            ${actionsCell}
        `;
        tbody.appendChild(tr);
    });
    
    localStorage.setItem('operators', JSON.stringify(operators));
    populateFilter();
    renderNextShifts(); // Update the sliding bar
}

/**
 * Renders the next 5 upcoming shifts into the sliding bar.
 */
function renderNextShifts() {
    const container = document.getElementById('nextShiftsContainer');
    container.innerHTML = '';
    
    if (operators.length === 0) {
        container.innerHTML = '<p style="padding: 0 15px; color:#999;">No schedule data available.</p>';
        return;
    }

    // 1. Find the current shift index in the full list
    let currentShiftIndex = operators.findIndex(op => {
        const opStart = getCleanDate(op.start);
        const opEnd = getCleanDate(op.end);
        return (today.getTime() >= opStart.getTime() && today.getTime() <= opEnd.getTime());
    });
    
    // If no active shift is found, find the nearest upcoming one
    if (currentShiftIndex === -1) {
        currentShiftIndex = operators.findIndex(op => getCleanDate(op.start).getTime() > today.getTime());
        // If still -1, schedule is not started or empty, so we start from the beginning if it's the first shift
        if (currentShiftIndex === -1) currentShiftIndex = 0;
    } else {
        // Start from the NEXT shift after the current one
        currentShiftIndex += 1;
    }

    // 2. Determine the range of shifts to display (next 5)
    const shiftsToShow = operators.slice(currentShiftIndex, currentShiftIndex + 5);

    if (shiftsToShow.length === 0) {
        container.innerHTML = '<p style="padding: 0 15px; color:#999;">No upcoming shifts found in the current schedule.</p>';
        return;
    }

    // 3. Create and append the cards
    shiftsToShow.forEach(op => {
        const card = document.createElement('div');
        card.className = 'shift-card';
        card.innerHTML = `
            <div class="shift-card-header">${op.name}</div>
            <p>Shift Start: <span class="date-range">${formatDate(op.start)}</span></p>
            <p>Shift End: <span class="date-range">${formatDate(op.end)}</span></p>
        `;
        container.appendChild(card);
    });
}


/* Add Operator (Full Admin Only) */
function addOperator() {
    if (!isAdmin) return alert('Full Admin privileges required for editing.');
    const name = document.getElementById('operatorName').value.trim().toUpperCase(); // Enforce uppercase for consistency
    const mobile = document.getElementById('mobileNumber').value.trim();
    const startDate = document.getElementById('startDate').value;

    if (!name || !mobile) return alert('Please fill in both Operator Name and Mobile Number.');
    if (!startDate) return alert('Please set the Schedule Start Date at the top.');

    const exists = INITIAL_OPERATORS_DATA.some(op => op.name.toLowerCase() === name.toLowerCase());
    if (exists) return alert('This operator name already exists.');

    INITIAL_OPERATORS_DATA.push({ name, mobile });
    
    if (!operatorPasswords[name]) {
        operatorPasswords[name] = 'op123';
        localStorage.setItem('operatorPasswords', JSON.stringify(operatorPasswords));
    }
    
    document.getElementById('operatorName').value = '';
    document.getElementById('mobileNumber').value = '';
    
    generateFullSchedule(startDate);
    renderTable();
    renderNextShifts(); // Update the sliding bar
    alert(`Operator ${name} added. Schedule re-generated for 1 year.`);
}

/* Reset Operator, Delete Operator, Reset All (Full Admin Only) */
function resetOperator(index) {
    if (!isAdmin) return alert('Full Admin privileges required for editing.');
    const startDate = document.getElementById('startDate').value;
    if (!startDate) return alert('Please set the Schedule Start Date at the top.');
    
    if (!confirm(`Reset the schedule to start from ${formatDate(startDate)} + 1 day? This will restart the entire rotation.`)) return;
    
    generateFullSchedule(startDate);
    renderTable();
    renderNextShifts(); 
    alert('Full schedule reset and regenerated.');
}

function deleteOperator(index) {
    if (!isAdmin) return alert('Full Admin privileges required for editing.');
    const startDate = document.getElementById('startDate').value;
    if (!startDate) return alert('Please set the Schedule Start Date at the top.');
    
    // Find the operator in the current schedule list to get the name
    const nameToDelete = operators[index].name;
    if (!confirm(`Delete operator ${nameToDelete} and their schedule? This will reset the entire future rotation.`)) return;

    // 1. Remove from the INITIAL_OPERATORS_DATA list
    const initialIndex = INITIAL_OPERATORS_DATA.findIndex(op => op.name === nameToDelete);
    if (initialIndex !== -1) {
        INITIAL_OPERATORS_DATA.splice(initialIndex, 1);
    }
    
    // 2. Remove password
    delete operatorPasswords[nameToDelete];
    localStorage.setItem('operatorPasswords', JSON.stringify(operatorPasswords));
    
    // 3. Regenerate the schedule from the start date with the reduced operator list
    generateFullSchedule(startDate);
    
    // 4. Update the display
    renderTable();
    renderNextShifts();
    alert(`Operator ${nameToDelete} deleted. Schedule re-generated.`);
}

function resetAll() {
    if (!isAdmin) return alert('Full Admin privileges required for this action.');
    if (!confirm('!!! WARNING !!! \n\nAre you absolutely sure you want to clear ALL schedule data (operators, passwords, and shifts) and reload the initial operators? This is irreversible.')) return;

    localStorage.clear();
    location.reload(); // Reloads the page, triggering the initial setup logic
}

/* --- Modals and Authentication --- */

let currentOperatorToRename = null; // Store the operator's original name

function openRenameModal(index) {
    if (!isAdmin) return alert('Full Admin privileges required for renaming.');
    renameIndex = index;
    currentOperatorToRename = operators[index].name;
    document.getElementById('newName').value = currentOperatorToRename;
    document.getElementById('renameModal').style.display = 'block';
}

function closeRenameModal() {
    document.getElementById('renameModal').style.display = 'none';
    renameIndex = null;
    currentOperatorToRename = null;
}

function confirmRename() {
    const newName = document.getElementById('newName').value.trim().toUpperCase();
    if (!newName) return alert('New name cannot be empty.');
    if (renameIndex === null) return;

    const oldName = currentOperatorToRename;
    const startDate = document.getElementById('startDate').value;
    if (!startDate) return alert('Please set the Schedule Start Date at the top.');

    // 1. Update INITIAL_OPERATORS_DATA
    const initialIndex = INITIAL_OPERATORS_DATA.findIndex(op => op.name === oldName);
    if (initialIndex !== -1) {
        INITIAL_OPERATORS_DATA[initialIndex].name = newName;
    }

    // 2. Update Passwords (transfer/rename the key)
    if (operatorPasswords[oldName]) {
        operatorPasswords[newName] = operatorPasswords[oldName];
        delete operatorPasswords[oldName];
        localStorage.setItem('operatorPasswords', JSON.stringify(operatorPasswords));
    }

    // 3. Regenerate schedule to apply the new name to all future shifts
    generateFullSchedule(startDate);

    closeRenameModal();
    renderTable();
    alert(`Operator "${oldName}" successfully renamed to "${newName}" and schedule re-generated.`);
}

function showDetailModal(op) {
    document.getElementById('detailOperatorName').textContent = op.name;
    document.getElementById('detailMobile').textContent = op.mobile;
    document.getElementById('detailStart').textContent = formatDate(op.start);
    document.getElementById('detailEnd').textContent = formatDate(op.end);
    document.getElementById('detailWorkingDays').textContent = countWorkingDays(op.start, op.end);
    document.getElementById('detailModal').style.display = 'block';
}

function closeDetailModal() {
    document.getElementById('detailModal').style.display = 'none';
}

function openChangePasswordModal() {
    document.getElementById('changePasswordModal').style.display = 'block';
    document.getElementById('newOpPassword').value = '';
    document.getElementById('confirmOpPassword').value = '';
}

function closeChangePasswordModal() {
    document.getElementById('changePasswordModal').style.display = 'none';
}

function confirmPasswordChange() {
    const newPwd = document.getElementById('newOpPassword').value;
    const confirmPwd = document.getElementById('confirmOpPassword').value;

    if (!loggedInUser || !isOperator) return alert('Must be logged in as an operator to change password.');
    if (newPwd.length < 5) return alert('Password must be at least 5 characters.');
    if (newPwd !== confirmPwd) return alert('New passwords do not match.');

    operatorPasswords[loggedInUser] = newPwd;
    localStorage.setItem('operatorPasswords', JSON.stringify(operatorPasswords));
    closeChangePasswordModal();
    alert('Password successfully changed!');
}


function updateUIBasedOnAuth() {
    const authSection = document.getElementById('authSection');
    const adminControls = document.getElementById('adminControls');
    const operatorFilter = document.getElementById('operatorFilter');
    const filterLabel = document.getElementById('filterLabel');
    const loginUsername = document.getElementById('loginUsername');
    const loginPassword = document.getElementById('adminPassword');
    const logoutBtn = document.getElementById('logoutBtn');
    const changePwdBtn = document.getElementById('changePwdBtn');
    const adminActionsBtn = document.getElementById('adminActionsBtn');

    if (loggedInUser) {
        authSection.style.display = 'none';
        logoutBtn.style.display = 'inline-block';
        adminActionsBtn.style.display = 'inline-block';

        if (isAdmin) {
            // Full Admin
            adminControls.style.display = 'block';
            operatorFilter.style.display = 'inline-block';
            filterLabel.style.display = 'inline-block';
            changePwdBtn.style.display = 'none';
        } else if (isRestrictedAdmin) {
            // View Admin
            adminControls.style.display = 'none';
            operatorFilter.style.display = 'inline-block';
            filterLabel.style.display = 'inline-block';
            changePwdBtn.style.display = 'none';
        } else if (isOperator) {
            // Operator View
            adminControls.style.display = 'none';
            operatorFilter.value = loggedInUser; // Automatically set filter to themselves
            operatorFilter.style.display = 'none'; // Hide dropdown
            filterLabel.style.display = 'none'; // Hide label
            changePwdBtn.style.display = 'inline-block';
        }

    } else {
        // Logged Out
        authSection.style.display = 'block';
        adminControls.style.display = 'none';
        logoutBtn.style.display = 'none';
        changePwdBtn.style.display = 'none';
        operatorFilter.value = ''; // Reset filter
        operatorFilter.style.display = 'none'; // Hide dropdown
        filterLabel.style.display = 'none'; // Hide label
        loginUsername.value = '';
        loginPassword.value = '';
        document.getElementById('actionsHeader').style.display = 'none';
    }
    renderTable(); // Re-render table based on new authentication state
}

function authenticate() {
    const username = document.getElementById('loginUsername').value.trim();
    const password = document.getElementById('adminPassword').value;

    // Reset state
    isAdmin = false;
    isRestrictedAdmin = false;
    isOperator = false;
    loggedInUser = null;

    // 1. Full Admin Check
    if (username === FULL_ADMIN_USER && password === FULL_ADMIN_PWD) {
        isAdmin = true;
        loggedInUser = FULL_ADMIN_USER;
        alert('Welcome, Full Admin!');
    }
    // 2. Restricted Admin Check
    else if (username === RESTRICTED_ADMIN_USER && password === RESTRICTED_ADMIN_PWD) {
        isRestrictedAdmin = true;
        loggedInUser = RESTRICTED_ADMIN_USER;
        alert('Welcome, View Admin!');
    }
    // 3. Operator Check
    else if (operatorPasswords[username.toUpperCase()] && operatorPasswords[username.toUpperCase()] === password) {
        isOperator = true;
        loggedInUser = username.toUpperCase();
        alert(`Welcome, ${loggedInUser}!`);
    }
    // Failed Login
    else {
        alert('Invalid username or password.');
        return;
    }

    updateUIBasedOnAuth();
}

function logout() {
    loggedInUser = null;
    isAdmin = false;
    isRestrictedAdmin = false;
    isOperator = false;
    document.getElementById('operatorFilter').value = '';
    updateUIBasedOnAuth();
    alert('Logged out successfully.');
}

function scrollToAdd() {
    const adminControls = document.getElementById('adminControls');
    const authSection = document.getElementById('authSection');
    
    // Scroll to Admin Controls if visible, otherwise scroll to Login/Auth section
    if (adminControls.style.display === 'block' && isAdmin) {
        adminControls.scrollIntoView({ behavior: 'smooth' });
    } else {
        authSection.scrollIntoView({ behavior: 'smooth' });
    }
}

// PDF Download logic (Requires jspdf.umd.min.js and jspdf-autotable.min.js)
function downloadPDF() {
    // Check for library existence using local scope variables
    if (typeof jspdf === 'undefined' || typeof jspdf.jsPDF === 'undefined' || typeof jspdf.jsPDF.prototype.autoTable === 'undefined') {
        alert('PDF or AutoTable library not loaded. Cannot download. Please ensure files (jspdf.umd.min.js and jspdf.plugin.autotable.min.js) are in the same folder as the HTML file.');
        return;
    }

    const { jsPDF } = jspdf;
    const doc = new jsPDF('l', 'mm', 'a4'); // Landscape, mm, A4

    const table = document.getElementById('scheduleTable');
    let title = 'Backup Operators Schedule';
    let subTitle = `Generated on ${formatDate(new Date())}`;

    // Get table data
    const headers = Array.from(table.tHead.rows[0].cells)
        .filter(cell => cell.id !== 'actionsHeader' || isAdmin) // Include Actions header only if Admin
        .map(cell => cell.textContent);

    const data = Array.from(table.tBodies[0].rows).map(row => {
        return Array.from(row.cells)
            // Filter out the last cell (Actions) if not Admin
            .filter((cell, index, array) => index < array.length - 1 || isAdmin) 
            .map(cell => cell.textContent.trim().replace(/\s{2,}/g, ' ')); // Clean up text
    });

    // Filtering logic for PDF title
    const selectedFilter = document.getElementById('operatorFilter').value;
    if (loggedInUser && isOperator) {
        title = `Schedule for Operator: ${loggedInUser}`;
    } else if (selectedFilter) {
        title = `Schedule for Operator: ${selectedFilter}`;
    }

    // Add Title and Subtitle
    doc.setFontSize(18);
    doc.text(title, doc.internal.pageSize.getWidth() / 2, 15, { align: 'center' });
    doc.setFontSize(10);
    doc.text(subTitle, doc.internal.pageSize.getWidth() / 2, 22, { align: 'center' });

    doc.autoTable({
        startY: 28,
        head: [headers],
        body: data,
        theme: 'grid',
        styles: { fontSize: 8, cellPadding: 2, overflow: 'linebreak' },
        headStyles: { fillColor: [148, 200, 61] }, // Green from CSS
        alternateRowStyles: { fillColor: [240, 240, 240] }
    });

    doc.save('Backup_Operators_Schedule.pdf');
}

// --- INITIALIZATION ---
function init() {
    // 1. Set the initial date input to the test/current date
    document.getElementById('startDate').value = today.toISOString().split('T')[0];
    
    // 2. Load or Generate the schedule (starting from the initial date)
    generateFullSchedule(document.getElementById('startDate').value);
    
    // 3. Render the UI
    updateUIBasedOnAuth(); // Will call renderTable() and renderNextShifts()
}

// Run initialization when the page is fully loaded
window.onload = init;
</script>
</body>
</html>
